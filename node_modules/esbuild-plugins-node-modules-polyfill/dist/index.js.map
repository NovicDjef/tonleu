{"version":3,"sources":["../src/lib/utils/util.ts","../src/lib/plugin.ts","../src/lib/polyfill.ts"],"names":["path","builtinModules","loadPackageJSON","polyfillPath"],"mappings":"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","sourcesContent":["export const escapeRegex = (str: string) => str.replace(/[$()*+.?[\\\\\\]^{|}]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n\nexport const commonJsTemplate = ({ importPath }: { importPath: string }) => `export * from '${importPath}'`;\n\nexport const normalizeNodeBuiltinPath = (path: string) => path.replace(/^node:/, '').replace(/\\/$/, '');\n","import { builtinModules } from 'node:module';\nimport path from 'node:path';\nimport process from 'node:process';\n\nimport { loadPackageJSON } from 'local-pkg';\n\nimport { getCachedPolyfillContent, getCachedPolyfillPath } from './polyfill.js';\nimport { escapeRegex, commonJsTemplate, normalizeNodeBuiltinPath } from './utils/util.js';\n\nimport type { OnResolveArgs, OnResolveResult, PartialMessage, Plugin } from 'esbuild';\nimport type esbuild from 'esbuild';\n\nconst NAME = 'node-modules-polyfills';\n\nexport interface NodePolyfillsOptions {\n\tfallback?: 'empty' | 'error' | 'none';\n\tformatError?: (\n\t\tthis: void,\n\t\targs: {\n\t\t\timporter: string;\n\t\t\tmoduleName: string;\n\t\t\tpolyfillExists: boolean;\n\t\t},\n\t) => PartialMessage | Promise<PartialMessage>;\n\tglobals?: {\n\t\tBuffer?: boolean;\n\t\tprocess?: boolean;\n\t};\n\tmodules?: Record<string, boolean | 'empty' | 'error'> | string[];\n\tname?: string;\n\tnamespace?: string;\n}\n\nconst loader = async (args: esbuild.OnLoadArgs): Promise<esbuild.OnLoadResult> => {\n\ttry {\n\t\tconst isCommonjs = args.namespace.endsWith('commonjs');\n\n\t\tconst resolved = await getCachedPolyfillPath(args.path);\n\t\tconst resolveDir = path.dirname(resolved);\n\n\t\tif (isCommonjs) {\n\t\t\treturn {\n\t\t\t\tloader: 'js',\n\t\t\t\tcontents: commonJsTemplate({\n\t\t\t\t\timportPath: args.path,\n\t\t\t\t}),\n\t\t\t\tresolveDir,\n\t\t\t};\n\t\t}\n\n\t\tconst contents = await getCachedPolyfillContent(args.path);\n\n\t\treturn {\n\t\t\tloader: 'js',\n\t\t\tcontents,\n\t\t\tresolveDir,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error('node-modules-polyfill', error);\n\t\treturn {\n\t\t\tcontents: `export {}`,\n\t\t\tloader: 'js',\n\t\t};\n\t}\n};\n\nexport const nodeModulesPolyfillPlugin = (options: NodePolyfillsOptions = {}): Plugin => {\n\tconst {\n\t\tglobals = {},\n\t\tmodules: modulesOption = builtinModules,\n\t\tfallback = 'none',\n\t\tformatError,\n\t\tnamespace = NAME,\n\t\tname = NAME,\n\t} = options;\n\tif (namespace.endsWith('commonjs')) throw new Error(`namespace ${namespace} must not end with commonjs`);\n\n\tif (namespace.endsWith('empty')) throw new Error(`namespace ${namespace} must not end with empty`);\n\n\tif (namespace.endsWith('error')) throw new Error(`namespace ${namespace} must not end with error`);\n\n\tconst modules = Array.isArray(modulesOption)\n\t\t? Object.fromEntries(modulesOption.map((mod) => [mod, true]))\n\t\t: modulesOption;\n\n\tconst commonjsNamespace = `${namespace}-commonjs`;\n\tconst emptyNamespace = `${namespace}-empty`;\n\tconst errorNamespace = `${namespace}-error`;\n\n\tconst shouldDetectErrorModules = fallback === 'error' || Object.values(modules).includes('error');\n\n\treturn {\n\t\tname,\n\t\tsetup: ({ onLoad, onResolve, onEnd, initialOptions }) => {\n\t\t\tif (shouldDetectErrorModules && initialOptions.write !== false)\n\t\t\t\tthrow new Error(`The \"write\" build option must be set to false when using the \"error\" polyfill type`);\n\n\t\t\tconst root = initialOptions.absWorkingDir ?? process.cwd();\n\n\t\t\t// polyfills contain global keyword, it must be defined\n\t\t\tif (initialOptions.define && !initialOptions.define.global) initialOptions.define.global = 'globalThis';\n\t\t\telse if (!initialOptions.define) initialOptions.define = { global: 'globalThis' };\n\n\t\t\tinitialOptions.inject = initialOptions.inject ?? [];\n\n\t\t\tif (globals.Buffer) initialOptions.inject.push(path.resolve(__dirname, '../globals/Buffer.js'));\n\n\t\t\tif (globals.process) initialOptions.inject.push(path.resolve(__dirname, '../globals/process.js'));\n\n\t\t\tonLoad({ filter: /.*/, namespace: emptyNamespace }, () => ({\n\t\t\t\tloader: 'js',\n\t\t\t\t// Use an empty CommonJS module here instead of ESM to avoid\n\t\t\t\t// \"No matching export\" errors in esbuild for anything that\n\t\t\t\t// is imported from this file.\n\t\t\t\tcontents: 'module.exports = {}',\n\t\t\t}));\n\n\t\t\tonLoad({ filter: /.*/, namespace: errorNamespace }, (args) => ({\n\t\t\t\tloader: 'js',\n\t\t\t\tcontents: `module.exports = ${JSON.stringify(\n\t\t\t\t\t// This encoded string is detected and parsed at the end of the build to report errors\n\t\t\t\t\t`__POLYFILL_ERROR_START__::MODULE::${args.path}::IMPORTER::${args.pluginData.importer}::__POLYFILL_ERROR_END__`,\n\t\t\t\t)}`,\n\t\t\t}));\n\n\t\t\tonLoad({ filter: /.*/, namespace }, loader);\n\t\t\tonLoad({ filter: /.*/, namespace: commonjsNamespace }, loader);\n\n\t\t\t// If we are using fallbacks, we need to handle all builtin modules so that we can replace their contents,\n\t\t\t// otherwise we only need to handle the modules that are configured (which is everything by default)\n\t\t\tconst bundledModules =\n\t\t\t\tfallback === 'none'\n\t\t\t\t\t? Object.keys(modules).filter((moduleName) => builtinModules.includes(moduleName))\n\t\t\t\t\t: builtinModules;\n\n\t\t\tconst filter = new RegExp(`^(?:node:)?(?:${bundledModules.map(escapeRegex).join('|')})$`);\n\n\t\t\tconst resolver = async (args: OnResolveArgs): Promise<OnResolveResult | undefined> => {\n\t\t\t\tconst result = {\n\t\t\t\t\tempty: {\n\t\t\t\t\t\tnamespace: emptyNamespace,\n\t\t\t\t\t\tpath: args.path,\n\t\t\t\t\t\tsideEffects: false,\n\t\t\t\t\t},\n\t\t\t\t\terror: {\n\t\t\t\t\t\tnamespace: errorNamespace,\n\t\t\t\t\t\tpath: args.path,\n\t\t\t\t\t\tsideEffects: false,\n\t\t\t\t\t\tpluginData: {\n\t\t\t\t\t\t\timporter: path.relative(root, args.importer).replace(/\\\\/g, '/'),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tnone: undefined,\n\t\t\t\t} as const satisfies Record<string, OnResolveResult | undefined>;\n\n\t\t\t\t// https://github.com/defunctzombie/package-browser-field-spec\n\t\t\t\tif (initialOptions.platform === 'browser') {\n\t\t\t\t\tconst packageJson = await loadPackageJSON(args.resolveDir);\n\t\t\t\t\tconst browserFieldValue = packageJson?.browser as unknown as\n\t\t\t\t\t\t| Record<string, string | false>\n\t\t\t\t\t\t| string\n\t\t\t\t\t\t| undefined;\n\n\t\t\t\t\tif (typeof browserFieldValue === 'string') return;\n\t\t\t\t\tconst browserFieldValueForModule = browserFieldValue?.[args.path];\n\n\t\t\t\t\t// This is here to support consumers who have used the\n\t\t\t\t\t// \"external\" option to exclude all Node builtins (e.g.\n\t\t\t\t\t// Remix v1 does this), otherwise the import/require is left\n\t\t\t\t\t// in the output and throws an error at runtime. Ideally we\n\t\t\t\t\t// would just return undefined for any browser field value,\n\t\t\t\t\t// and we can safely switch to this in a major version.\n\t\t\t\t\tif (browserFieldValueForModule === false) return result.empty;\n\n\t\t\t\t\tif (browserFieldValueForModule !== undefined) return;\n\t\t\t\t}\n\n\t\t\t\tconst moduleName = normalizeNodeBuiltinPath(args.path);\n\t\t\t\tconst polyfillOption = modules[moduleName];\n\n\t\t\t\tif (!polyfillOption) return result[fallback];\n\n\t\t\t\tif (polyfillOption === 'error' || polyfillOption === 'empty') return result[polyfillOption];\n\n\t\t\t\tconst polyfillPath = await getCachedPolyfillPath(moduleName).catch(() => null);\n\n\t\t\t\tif (!polyfillPath) return result[fallback];\n\n\t\t\t\tconst ignoreRequire = args.namespace === commonjsNamespace;\n\t\t\t\tconst isCommonjs = !ignoreRequire && args.kind === 'require-call';\n\n\t\t\t\treturn {\n\t\t\t\t\tnamespace: isCommonjs ? commonjsNamespace : namespace,\n\t\t\t\t\tpath: args.path,\n\t\t\t\t\tsideEffects: false,\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tonResolve({ filter }, resolver);\n\n\t\t\tonEnd(async ({ outputFiles = [] }) => {\n\t\t\t\t// This logic needs to be run when the build is complete because\n\t\t\t\t// we need to check the output files after tree-shaking has been\n\t\t\t\t// performed. If we did this in the onLoad hook, we could throw\n\t\t\t\t// errors for modules that are not even present in the final\n\t\t\t\t// output. This is particularly important when building projects\n\t\t\t\t// that target both server and browser since the browser build\n\t\t\t\t// may not use all of the modules that the server build does. If\n\t\t\t\t// you're only building for the browser, this feature is less\n\t\t\t\t// useful since any unpolyfilled modules will be treated just\n\t\t\t\t// like any other missing module.\n\n\t\t\t\tif (!shouldDetectErrorModules) return;\n\n\t\t\t\tconst errors: PartialMessage[] = [];\n\n\t\t\t\tconst { outfile, outExtension = {} } = initialOptions;\n\t\t\t\tconst jsExtension = outfile ? path.extname(outfile) : outExtension['.js'] || '.js';\n\t\t\t\tconst jsFiles = outputFiles.filter((file) => path.extname(file.path) === jsExtension);\n\n\t\t\t\tfor (const file of jsFiles) {\n\t\t\t\t\tconst matches = file.text.matchAll(\n\t\t\t\t\t\t/__POLYFILL_ERROR_START__::MODULE::(?<moduleName>.+?)::IMPORTER::(?<importer>.+?)::__POLYFILL_ERROR_END__/g,\n\t\t\t\t\t);\n\n\t\t\t\t\tfor (const { groups } of matches) {\n\t\t\t\t\t\tconst { moduleName, importer } = groups!;\n\t\t\t\t\t\tconst polyfillExists = (await getCachedPolyfillPath(moduleName).catch(() => null)) !== null;\n\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\tpluginName: name,\n\t\t\t\t\t\t\ttext: polyfillExists\n\t\t\t\t\t\t\t\t? `Polyfill has not been configured for \"${moduleName}\", imported by \"${importer}\"`\n\t\t\t\t\t\t\t\t: `Polyfill does not exist for \"${moduleName}\", imported by \"${importer}\"`,\n\t\t\t\t\t\t\t...(formatError ? await formatError({ moduleName, importer, polyfillExists }) : {}),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn { errors };\n\t\t\t});\n\t\t},\n\t};\n};\n","import { readFile } from 'node:fs/promises';\nimport { builtinModules } from 'node:module';\nimport { resolve, join } from 'node:path';\n\nimport { loadPackageJSON, resolveModule } from 'local-pkg';\nimport { resolve as resolveExports } from 'resolve.exports';\n\nimport { normalizeNodeBuiltinPath } from './utils/util.js';\n\nasync function polyfillPath(importPath: string) {\n\tif (!builtinModules.includes(importPath))\n\t\tthrow new Error(`Node.js does not have ${importPath} in its builtin modules`);\n\n\tconst jspmPath = resolve(\n\t\trequire.resolve(`@jspm/core/nodelibs/${importPath}`),\n\t\t// ensure sub path modules are resolved properly\n\t\t'../../..' + (importPath.includes('/') ? '/..' : ''),\n\t);\n\n\tconst jspmPackageJson = await loadPackageJSON(jspmPath);\n\tconst exportPath = resolveExports(jspmPackageJson, `./nodelibs/${importPath}`, {\n\t\tbrowser: true,\n\t});\n\n\tconst exportFullPath = resolveModule(join(jspmPath, exportPath?.[0] ?? ''));\n\n\tif (!exportPath || !exportFullPath) {\n\t\tthrow new Error(\n\t\t\t'resolving failed, please try creating an issue in https://github.com/imranbarbhuiya/esbuild-plugins-node-modules-polyfill',\n\t\t);\n\t}\n\n\treturn exportFullPath;\n}\n\nconst polyfillPathCache: Map<string, Promise<string>> = new Map();\nexport const getCachedPolyfillPath = (importPath: string): Promise<string> => {\n\tconst normalizedImportPath = normalizeNodeBuiltinPath(importPath);\n\n\tconst cachedPromise = polyfillPathCache.get(normalizedImportPath);\n\tif (cachedPromise) return cachedPromise;\n\n\tconst promise = polyfillPath(normalizedImportPath);\n\tpolyfillPathCache.set(normalizedImportPath, promise);\n\treturn promise;\n};\n\nexport const polyfillContentAndTransform = async (importPath: string) => {\n\tconst exportFullPath = await getCachedPolyfillPath(importPath);\n\n\tconst content = await readFile(exportFullPath, 'utf8');\n\n\treturn content.replace(/eval\\(/g, '(0,eval)(');\n};\n\nconst polyfillContentCache: Map<string, Promise<string>> = new Map();\nexport const getCachedPolyfillContent = (_importPath: string): Promise<string> => {\n\tconst normalizedImportPath = normalizeNodeBuiltinPath(_importPath);\n\n\tconst cachedPromise = polyfillContentCache.get(normalizedImportPath);\n\tif (cachedPromise) return cachedPromise;\n\n\tconst promise = polyfillContentAndTransform(normalizedImportPath);\n\tpolyfillContentCache.set(normalizedImportPath, promise);\n\treturn promise;\n};\n"]}